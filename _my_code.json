{
    "bo_slices": [
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "262",
                "name": "HMAC_CTX_reset",
                "location": "75",
                "code": "HMAC_CTX_reset(ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "261",
                "name": "<operator>.logicalNot",
                "location": "75",
                "code": "!HMAC_CTX_reset(ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "criterion": {
                "type": "CALL",
                "ID": "265",
                "name": "HMAC_CTX_free",
                "location": "76",
                "code": "HMAC_CTX_free(ctx)"
            }
        },
        {
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "criterion": {
                "type": "CALL",
                "ID": "250",
                "name": "<operator>.assignment",
                "location": "72",
                "code": "*ctx = OPENSSL_zalloc(sizeof(HMAC_CTX))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "145": "    if (reset) {\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "criterion": {
                "type": "CALL",
                "ID": "535",
                "name": "EVP_DigestInit_ex",
                "location": "148",
                "code": "EVP_DigestInit_ex(ctx->i_ctx, md, impl)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "547",
                "name": "EVP_MD_block_size",
                "location": "149",
                "code": "EVP_MD_block_size(md)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "587",
                "name": "EVP_MD_block_size",
                "location": "155",
                "code": "EVP_MD_block_size(md)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "criterion": {
                "type": "CALL",
                "ID": "436",
                "name": "EVP_DigestUpdate",
                "location": "130",
                "code": "EVP_DigestUpdate(ctx->md_ctx, key, len)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "criterion": {
                "type": "CALL",
                "ID": "475",
                "name": "memcpy",
                "location": "137",
                "code": "memcpy(ctx->key, key, len)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "534",
                "name": "<operator>.logicalNot",
                "location": "148",
                "code": "!EVP_DigestInit_ex(ctx->i_ctx, md, impl)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "criterion": {
                "type": "CALL",
                "ID": "575",
                "name": "EVP_DigestInit_ex",
                "location": "154",
                "code": "EVP_DigestInit_ex(ctx->o_ctx, md, impl)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "criterion": {
                "type": "CALL",
                "ID": "402",
                "name": "<operator>.assignment",
                "location": "125",
                "code": "j = EVP_MD_block_size(md)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "criterion": {
                "type": "CALL",
                "ID": "592",
                "name": "<operator>.logicalNot",
                "location": "158",
                "code": "!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "581",
                "name": "<operator>.logicalNot",
                "location": "155",
                "code": "!EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "574",
                "name": "<operator>.logicalNot",
                "location": "154",
                "code": "!EVP_DigestInit_ex(ctx->o_ctx, md, impl)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "criterion": {
                "type": "CALL",
                "ID": "593",
                "name": "EVP_MD_CTX_copy_ex",
                "location": "158",
                "code": "EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "criterion": {
                "type": "CALL",
                "ID": "404",
                "name": "EVP_MD_block_size",
                "location": "125",
                "code": "EVP_MD_block_size(md)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "criterion": {
                "type": "CALL",
                "ID": "435",
                "name": "<operator>.logicalNot",
                "location": "130",
                "code": "!EVP_DigestUpdate(ctx->md_ctx, key, len)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "541",
                "name": "<operator>.logicalNot",
                "location": "149",
                "code": "!EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "criterion": {
                "type": "CALL",
                "ID": "428",
                "name": "<operator>.logicalNot",
                "location": "129",
                "code": "!EVP_DigestInit_ex(ctx->md_ctx, md, impl)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "criterion": {
                "type": "CALL",
                "ID": "429",
                "name": "EVP_DigestInit_ex",
                "location": "129",
                "code": "EVP_DigestInit_ex(ctx->md_ctx, md, impl)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "criterion": {
                "type": "CALL",
                "ID": "609",
                "name": "OPENSSL_cleanse",
                "location": "163",
                "code": "OPENSSL_cleanse(pad, sizeof(pad))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "407",
                "name": "<operator>.logicalNot",
                "location": "126",
                "code": "!ossl_assert(j <= (int)sizeof(ctx->key))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "582",
                "name": "EVP_DigestUpdate",
                "location": "155",
                "code": "EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "542",
                "name": "EVP_DigestUpdate",
                "location": "149",
                "code": "EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "criterion": {
                "type": "CALL",
                "ID": "408",
                "name": "ossl_assert",
                "location": "126",
                "code": "ossl_assert(j <= (int)sizeof(ctx->key))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "279",
                "name": "<operator>.logicalNot",
                "location": "86",
                "code": "!hmac_ctx_alloc_mds(ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "criterion": {
                "type": "CALL",
                "ID": "276",
                "name": "hmac_ctx_cleanup",
                "location": "85",
                "code": "hmac_ctx_cleanup(ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "280",
                "name": "hmac_ctx_alloc_mds",
                "location": "86",
                "code": "hmac_ctx_alloc_mds(ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "criterion": {
                "type": "CALL",
                "ID": "283",
                "name": "hmac_ctx_cleanup",
                "location": "87",
                "code": "hmac_ctx_cleanup(ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "criterion": {
                "type": "CALL",
                "ID": "316",
                "name": "OPENSSL_cleanse",
                "location": "100",
                "code": "OPENSSL_cleanse(ctx->key, sizeof(ctx->key))"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "criterion": {
                "type": "CALL",
                "ID": "298",
                "name": "EVP_MD_CTX_reset",
                "location": "96",
                "code": "EVP_MD_CTX_reset(ctx->o_ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "criterion": {
                "type": "CALL",
                "ID": "294",
                "name": "EVP_MD_CTX_reset",
                "location": "95",
                "code": "EVP_MD_CTX_reset(ctx->i_ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "criterion": {
                "type": "CALL",
                "ID": "302",
                "name": "EVP_MD_CTX_reset",
                "location": "97",
                "code": "EVP_MD_CTX_reset(ctx->md_ctx)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "230",
                "name": "<operator>.logicalNot",
                "location": "62",
                "code": "!HMAC_Final(hmac, mac, maclen)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "criterion": {
                "type": "CALL",
                "ID": "198",
                "name": "<operator>.assignment",
                "location": "58",
                "code": "hmac = HMAC_CTX_new()"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "28": "    if (!p12->mac->iter)\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "criterion": {
                "type": "CALL",
                "ID": "85",
                "name": "ASN1_INTEGER_get",
                "location": "31",
                "code": "ASN1_INTEGER_get(p12->mac->iter)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "criterion": {
                "type": "CALL",
                "ID": "236",
                "name": "HMAC_CTX_free",
                "location": "63",
                "code": "HMAC_CTX_free(hmac)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "criterion": {
                "type": "CALL",
                "ID": "119",
                "name": "<operator>.assignment",
                "location": "38",
                "code": "md_size = EVP_MD_size(md_type)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "criterion": {
                "type": "CALL",
                "ID": "123",
                "name": "<operator>.assignment",
                "location": "39",
                "code": "md_type_nid = EVP_MD_type(md_type)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "criterion": {
                "type": "CALL",
                "ID": "203",
                "name": "HMAC_Init_ex",
                "location": "59",
                "code": "HMAC_Init_ex(hmac, key, md_size, md_type, NULL)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "107",
                "name": "<operator>.equals",
                "location": "34",
                "code": "(md_type = EVP_get_digestbyobj(macoid)) == NULL"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "231",
                "name": "HMAC_Final",
                "location": "62",
                "code": "HMAC_Final(hmac, mac, maclen)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "criterion": {
                "type": "CALL",
                "ID": "200",
                "name": "HMAC_CTX_new",
                "location": "58",
                "code": "HMAC_CTX_new()"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "28": "    if (!p12->mac->iter)\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "criterion": {
                "type": "CALL",
                "ID": "83",
                "name": "<operator>.assignment",
                "location": "31",
                "code": "iter = ASN1_INTEGER_get(p12->mac->iter)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "criterion": {
                "type": "CALL",
                "ID": "91",
                "name": "X509_SIG_get0",
                "location": "32",
                "code": "X509_SIG_get0(p12->mac->dinfo, &macalg, NULL)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "criterion": {
                "type": "CALL",
                "ID": "125",
                "name": "EVP_MD_type",
                "location": "39",
                "code": "EVP_MD_type(md_type)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "criterion": {
                "type": "CALL",
                "ID": "121",
                "name": "EVP_MD_size",
                "location": "38",
                "code": "EVP_MD_size(md_type)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "criterion": {
                "type": "CALL",
                "ID": "240",
                "name": "HMAC_CTX_free",
                "location": "66",
                "code": "HMAC_CTX_free(hmac)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "41",
                "name": "<operator>.logicalNot",
                "location": "21",
                "code": "!PKCS7_type_is_data(p12->authsafes)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "108",
                "name": "<operator>.assignment",
                "location": "34",
                "code": "md_type = EVP_get_digestbyobj(macoid)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "110",
                "name": "EVP_get_digestbyobj",
                "location": "34",
                "code": "EVP_get_digestbyobj(macoid)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "176",
                "name": "<operator>.indirection",
                "location": "53",
                "code": "*pkcs12_key_gen"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "criterion": {
                "type": "CALL",
                "ID": "197",
                "name": "<operator>.equals",
                "location": "58",
                "code": "(hmac = HMAC_CTX_new()) == NULL"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "criterion": {
                "type": "CALL",
                "ID": "202",
                "name": "<operator>.logicalNot",
                "location": "59",
                "code": "!HMAC_Init_ex(hmac, key, md_size, md_type, NULL)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "42",
                "name": "PKCS7_type_is_data",
                "location": "21",
                "code": "PKCS7_type_is_data(p12->authsafes)"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "criterion": {
                "type": "CALL",
                "ID": "100",
                "name": "X509_ALGOR_get0",
                "location": "33",
                "code": "X509_ALGOR_get0(&macoid, NULL, NULL, macalg)"
            }
        }
    ],
    "ml_slices": [
        {
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "criterion": {
                "type": "CALL",
                "ID": "252",
                "name": "OPENSSL_zalloc",
                "location": "72",
                "code": "OPENSSL_zalloc(sizeof(HMAC_CTX))"
            }
        },
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "404",
                "name": "EVP_MD_block_size",
                "location": "125",
                "code": "EVP_MD_block_size(md)"
            }
        },
        {
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "200",
                "name": "HMAC_CTX_new",
                "location": "58",
                "code": "HMAC_CTX_new()"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "121",
                "name": "EVP_MD_size",
                "location": "38",
                "code": "EVP_MD_size(md_type)"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "125",
                "name": "EVP_MD_type",
                "location": "39",
                "code": "EVP_MD_type(md_type)"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "85",
                "name": "ASN1_INTEGER_get",
                "location": "31",
                "code": "ASN1_INTEGER_get(p12->mac->iter)"
            }
        },
        {
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "110",
                "name": "EVP_get_digestbyobj",
                "location": "34",
                "code": "EVP_get_digestbyobj(macoid)"
            }
        }
    ],
    "io_slices": [],
    "np_slices": [
        {
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "252",
                "name": "OPENSSL_zalloc",
                "location": "72",
                "code": "OPENSSL_zalloc(sizeof(HMAC_CTX))"
            }
        },
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "criterion": {
                "type": "CALL",
                "ID": "404",
                "name": "EVP_MD_block_size",
                "location": "125",
                "code": "EVP_MD_block_size(md)"
            }
        },
        {
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "criterion": {
                "type": "CALL",
                "ID": "200",
                "name": "HMAC_CTX_new",
                "location": "58",
                "code": "HMAC_CTX_new()"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "criterion": {
                "type": "CALL",
                "ID": "121",
                "name": "EVP_MD_size",
                "location": "38",
                "code": "EVP_MD_size(md_type)"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "criterion": {
                "type": "CALL",
                "ID": "125",
                "name": "EVP_MD_type",
                "location": "39",
                "code": "EVP_MD_type(md_type)"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "criterion": {
                "type": "CALL",
                "ID": "85",
                "name": "ASN1_INTEGER_get",
                "location": "31",
                "code": "ASN1_INTEGER_get(p12->mac->iter)"
            }
        },
        {
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "criterion": {
                "type": "CALL",
                "ID": "110",
                "name": "EVP_get_digestbyobj",
                "location": "34",
                "code": "EVP_get_digestbyobj(macoid)"
            }
        }
    ],
    "uaf_slices": [
        {
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "criterion": {
                "type": "CALL",
                "ID": "252",
                "name": "OPENSSL_zalloc",
                "location": "72",
                "code": "OPENSSL_zalloc(sizeof(HMAC_CTX))"
            }
        },
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "404",
                "name": "EVP_MD_block_size",
                "location": "125",
                "code": "EVP_MD_block_size(md)"
            }
        },
        {
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "200",
                "name": "HMAC_CTX_new",
                "location": "58",
                "code": "HMAC_CTX_new()"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "121",
                "name": "EVP_MD_size",
                "location": "38",
                "code": "EVP_MD_size(md_type)"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "125",
                "name": "EVP_MD_type",
                "location": "39",
                "code": "EVP_MD_type(md_type)"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "85",
                "name": "ASN1_INTEGER_get",
                "location": "31",
                "code": "ASN1_INTEGER_get(p12->mac->iter)"
            }
        },
        {
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "110",
                "name": "EVP_get_digestbyobj",
                "location": "34",
                "code": "EVP_get_digestbyobj(macoid)"
            }
        }
    ],
    "df_slices": [
        {
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "criterion": {
                "type": "CALL",
                "ID": "250",
                "name": "<operator>.assignment",
                "location": "72",
                "code": "*ctx = OPENSSL_zalloc(sizeof(HMAC_CTX))"
            }
        },
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "criterion": {
                "type": "CALL",
                "ID": "402",
                "name": "<operator>.assignment",
                "location": "125",
                "code": "j = EVP_MD_block_size(md)"
            }
        },
        {
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "160": "    rv = 1;\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "198",
                "name": "<operator>.assignment",
                "location": "58",
                "code": "hmac = HMAC_CTX_new()"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "160": "    rv = 1;\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "119",
                "name": "<operator>.assignment",
                "location": "38",
                "code": "md_size = EVP_MD_size(md_type)"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "160": "    rv = 1;\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "123",
                "name": "<operator>.assignment",
                "location": "39",
                "code": "md_type_nid = EVP_MD_type(md_type)"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "160": "    rv = 1;\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "83",
                "name": "<operator>.assignment",
                "location": "31",
                "code": "iter = ASN1_INTEGER_get(p12->mac->iter)"
            }
        },
        {
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "43": "         || md_type_nid == NID_id_GostR3411_2012_256\n",
            "44": "         || md_type_nid == NID_id_GostR3411_2012_512)\n",
            "45": "        && !getenv(\"LEGACY_GOST_PKCS12\")) {\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "48": "                                     md_size, key, md_type)) {\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "54": "                               iter, md_size, key, md_type)) {\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "59": "        || !HMAC_Init_ex(hmac, key, md_size, md_type, NULL)\n",
            "60": "        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n",
            "61": "                        p12->authsafes->d.data->length)\n",
            "62": "        || !HMAC_Final(hmac, mac, maclen)) {\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "70": "HMAC_CTX *HMAC_CTX_new(void)\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "130": "                    || !EVP_DigestUpdate(ctx->md_ctx, key, len)\n",
            "131": "                    || !EVP_DigestFinal_ex(ctx->md_ctx, ctx->key,\n",
            "132": "                                           &ctx->key_length))\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "142": "                   HMAC_MAX_MD_CBLOCK - ctx->key_length);\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "149": "                || !EVP_DigestUpdate(ctx->i_ctx, pad, EVP_MD_block_size(md)))\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "155": "                || !EVP_DigestUpdate(ctx->o_ctx, pad, EVP_MD_block_size(md)))\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "160": "    rv = 1;\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "CALL",
                "ID": "108",
                "name": "<operator>.assignment",
                "location": "34",
                "code": "md_type = EVP_get_digestbyobj(macoid)"
            }
        }
    ]
}