{
    "bo_slices": [
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538307",
                "code": "HMAC_CTX_free ( ctx )",
                "location": "76"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538484",
                "code": "OPENSSL_cleanse ( pad , sizeof ( pad ) )",
                "location": "163"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538652",
                "code": "memset ( & ctx -> key [ ctx -> key_length ] , 0 , HMAC_MAX_MD_CBLOCK - ctx -> key_length )",
                "location": "141"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538690",
                "code": "memcpy ( ctx -> key , key , len )",
                "location": "137"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "114": "    if (md != NULL) {\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "123": "    if (key != NULL) {\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538799",
                "code": "j = EVP_MD_block_size ( md )",
                "location": "125"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538361",
                "code": "hmac_ctx_cleanup ( ctx )",
                "location": "87"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538377",
                "code": "hmac_ctx_cleanup ( ctx )",
                "location": "85"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "5",
                "ID": "5538396",
                "code": "OPENSSL_cleanse ( ctx -> key , sizeof ( ctx -> key ) )",
                "location": "100"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "2",
                "ID": "5538423",
                "code": "EVP_MD_CTX_reset ( ctx -> md_ctx )",
                "location": "97"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538432",
                "code": "EVP_MD_CTX_reset ( ctx -> o_ctx )",
                "location": "96"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538441",
                "code": "EVP_MD_CTX_reset ( ctx -> i_ctx )",
                "location": "95"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "21",
                "ID": "5537834",
                "code": "HMAC_CTX_free ( hmac )",
                "location": "66"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "2": "                          unsigned char *mac, unsigned int *maclen,\n",
            "3": "                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n",
            "10": "    HMAC_CTX *hmac = NULL;\n",
            "11": "    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "18": "    if (pkcs12_key_gen == NULL)\n",
            "19": "        pkcs12_key_gen = PKCS12_key_gen_utf8;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "26": "    salt = p12->mac->salt->data;\n",
            "27": "    saltlen = p12->mac->salt->length;\n",
            "28": "    if (!p12->mac->iter)\n",
            "29": "        iter = 1;\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5537845",
                "code": "HMAC_CTX_free ( hmac )",
                "location": "63"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "17",
                "ID": "5538031",
                "code": "md_type_nid = EVP_MD_type ( md_type )",
                "location": "39"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "16": "    const ASN1_OBJECT *macoid;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "16",
                "ID": "5538040",
                "code": "md_size = EVP_MD_size ( md_type )",
                "location": "38"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "15": "    const X509_ALGOR *macalg;\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "14",
                "ID": "5538073",
                "code": "X509_ALGOR_get0 ( & macoid , NULL , NULL , macalg )",
                "location": "33"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "13",
                "ID": "5538088",
                "code": "X509_SIG_get0 ( p12 -> mac -> dinfo , & macalg , NULL )",
                "location": "32"
            }
        },
        {
            "1": "static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n",
            "21": "    if (!PKCS7_type_is_data(p12->authsafes)) {\n",
            "28": "    if (!p12->mac->iter)\n",
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538107",
                "code": "iter = ASN1_INTEGER_get ( p12 -> mac -> iter )",
                "location": "31"
            }
        }
    ],
    "ml_slices": [
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538799",
                "code": "j = EVP_MD_block_size ( md )",
                "location": "125"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "17",
                "ID": "5538031",
                "code": "md_type_nid = EVP_MD_type ( md_type )",
                "location": "39"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "16",
                "ID": "5538040",
                "code": "md_size = EVP_MD_size ( md_type )",
                "location": "38"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538107",
                "code": "iter = ASN1_INTEGER_get ( p12 -> mac -> iter )",
                "location": "31"
            }
        }
    ],
    "io_slices": [],
    "np_slices": [
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538799",
                "code": "j = EVP_MD_block_size ( md )",
                "location": "125"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "17",
                "ID": "5538031",
                "code": "md_type_nid = EVP_MD_type ( md_type )",
                "location": "39"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "16",
                "ID": "5538040",
                "code": "md_size = EVP_MD_size ( md_type )",
                "location": "38"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538107",
                "code": "iter = ASN1_INTEGER_get ( p12 -> mac -> iter )",
                "location": "31"
            }
        }
    ],
    "uaf_slices": [
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538799",
                "code": "j = EVP_MD_block_size ( md )",
                "location": "125"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "17",
                "ID": "5538031",
                "code": "md_type_nid = EVP_MD_type ( md_type )",
                "location": "39"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "16",
                "ID": "5538040",
                "code": "md_size = EVP_MD_size ( md_type )",
                "location": "38"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "32": "    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n",
            "33": "    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n",
            "34": "    if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {\n",
            "35": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n",
            "36": "        return 0;\n",
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "41": "        return 0;\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "46": "        md_size = TK26_MAC_KEY_LEN;\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "49": "            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "50": "            return 0;\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "55": "        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\n",
            "56": "        return 0;\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "64": "        return 0;\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "67": "    return 1;\n",
            "72": "    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n",
            "74": "    if (ctx != NULL) {\n",
            "75": "        if (!HMAC_CTX_reset(ctx)) {\n",
            "76": "            HMAC_CTX_free(ctx);\n",
            "77": "            return NULL;\n",
            "80": "    return ctx;\n",
            "83": "int HMAC_CTX_reset(HMAC_CTX *ctx)\n",
            "85": "    hmac_ctx_cleanup(ctx);\n",
            "86": "    if (!hmac_ctx_alloc_mds(ctx)) {\n",
            "87": "        hmac_ctx_cleanup(ctx);\n",
            "88": "        return 0;\n",
            "90": "    return 1;\n",
            "93": "static void hmac_ctx_cleanup(HMAC_CTX *ctx)\n",
            "95": "    EVP_MD_CTX_reset(ctx->i_ctx);\n",
            "96": "    EVP_MD_CTX_reset(ctx->o_ctx);\n",
            "97": "    EVP_MD_CTX_reset(ctx->md_ctx);\n",
            "98": "    ctx->md = NULL;\n",
            "99": "    ctx->key_length = 0;\n",
            "100": "    OPENSSL_cleanse(ctx->key, sizeof(ctx->key));\n",
            "103": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n",
            "104": "                 const EVP_MD *md, ENGINE *impl)\n",
            "106": "    int rv = 0;\n",
            "107": "    int i, j, reset = 0;\n",
            "108": "    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n",
            "111": "    if (md != NULL && md != ctx->md && (key == NULL || len < 0))\n",
            "112": "        return 0;\n",
            "114": "    if (md != NULL) {\n",
            "115": "        reset = 1;\n",
            "116": "        ctx->md = md;\n",
            "117": "    } else if (ctx->md) {\n",
            "118": "        md = ctx->md;\n",
            "120": "        return 0;\n",
            "123": "    if (key != NULL) {\n",
            "124": "        reset = 1;\n",
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "127": "            return 0;\n",
            "128": "        if (j < len) {\n",
            "129": "            if (!EVP_DigestInit_ex(ctx->md_ctx, md, impl)\n",
            "133": "                return 0;\n",
            "135": "            if (len < 0 || len > (int)sizeof(ctx->key))\n",
            "136": "                return 0;\n",
            "137": "            memcpy(ctx->key, key, len);\n",
            "138": "            ctx->key_length = len;\n",
            "140": "        if (ctx->key_length != HMAC_MAX_MD_CBLOCK)\n",
            "141": "            memset(&ctx->key[ctx->key_length], 0,\n",
            "145": "    if (reset) {\n",
            "146": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "147": "            pad[i] = 0x36 ^ ctx->key[i];\n",
            "148": "        if (!EVP_DigestInit_ex(ctx->i_ctx, md, impl)\n",
            "150": "            goto err;\n",
            "152": "        for (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\n",
            "153": "            pad[i] = 0x5c ^ ctx->key[i];\n",
            "154": "        if (!EVP_DigestInit_ex(ctx->o_ctx, md, impl)\n",
            "156": "            goto err;\n",
            "158": "    if (!EVP_MD_CTX_copy_ex(ctx->md_ctx, ctx->i_ctx))\n",
            "159": "        goto err;\n",
            "160": "    rv = 1;\n",
            "161": " err:\n",
            "162": "    if (reset)\n",
            "163": "        OPENSSL_cleanse(pad, sizeof(pad));\n",
            "164": "    return rv;\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538107",
                "code": "iter = ASN1_INTEGER_get ( p12 -> mac -> iter )",
                "location": "31"
            }
        }
    ],
    "df_slices": [
        {
            "125": "        j = EVP_MD_block_size(md);\n",
            "126": "        if (!ossl_assert(j <= (int)sizeof(ctx->key)))\n",
            "128": "        if (j < len) {\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "1",
                "ID": "5538799",
                "code": "j = EVP_MD_block_size ( md )",
                "location": "125"
            }
        },
        {
            "39": "    md_type_nid = EVP_MD_type(md_type);\n",
            "42": "    if ((md_type_nid == NID_id_GostR3411_94\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "17",
                "ID": "5538031",
                "code": "md_type_nid = EVP_MD_type ( md_type )",
                "location": "39"
            }
        },
        {
            "38": "    md_size = EVP_MD_size(md_type);\n",
            "40": "    if (md_size < 0)\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "58": "    if ((hmac = HMAC_CTX_new()) == NULL\n",
            "63": "        HMAC_CTX_free(hmac);\n",
            "66": "    HMAC_CTX_free(hmac);\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "16",
                "ID": "5538040",
                "code": "md_size = EVP_MD_size ( md_type )",
                "location": "38"
            }
        },
        {
            "31": "        iter = ASN1_INTEGER_get(p12->mac->iter);\n",
            "47": "        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n",
            "53": "        if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n",
            "criterion": {
                "type": "EXPRSTATE",
                "childNum": "0",
                "ID": "5538107",
                "code": "iter = ASN1_INTEGER_get ( p12 -> mac -> iter )",
                "location": "31"
            }
        }
    ]
}